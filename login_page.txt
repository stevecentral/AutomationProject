# Form implementation generated from reading ui file 'main_window.ui'
#
# Created by: PyQt6 UI code generator 6.8.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


import os
import subprocess
import time
import telnetlib3
import asyncio
from threading import Thread, Event
from queue import Queue
from PyQt6.QtWidgets import QFileDialog
from PyQt6 import QtCore, QtGui, QtWidgets


import socket
import select
from threading import Thread, Event
from queue import Queue
from PyQt6 import QtCore, QtGui, QtWidgets

class LogHandler:
    def __init__(self, host, port=23):
        self.host = host
        self.port = port
        self.socket = None
        self.stop_event = Event()
        self.log_queue = Queue()
        self.connected = False

    def connect(self):
        try:
            print(f"Attempting to connect to {self.host}:{self.port}")
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.host, self.port))
            self.socket.setblocking(False)  # Set non-blocking immediately
            self.connected = True
            print("Connection established")
            return True
        except Exception as e:
            print(f"Connection failed: {str(e)}")
            return False

    def start_logging(self):
        def read_log():
            while not self.stop_event.is_set():
                try:
                    # Use select with a timeout
                    ready = select.select([self.socket], [], [], 0.1)
                    if ready[0]:
                        data = self.socket.recv(4096)  # Increased buffer size
                        if data:
                            decoded_data = data.decode('utf-8', errors='ignore')
                            print(f"Received data: {decoded_data}")  # Debug print
                            self.log_queue.put(decoded_data)
                except socket.error as e:
                    if e.errno != socket.errno.EAGAIN and e.errno != socket.errno.EWOULDBLOCK:
                        print(f"Socket error: {e}")
                        break
                except Exception as e:
                    print(f"Error reading logs: {str(e)}")
                    break

        self.stop_event.clear()
        Thread(target=read_log, daemon=True).start()


class Ui_Dialog(object):
    def __init__(self):
        self.log_handler = None
        self.log_update_timer = None
        self.test_thread = None


    def run_script_generator(self):
        """Run tests in a separate thread"""

        def run_tests():
            try:
                # Get the correct IP address to use
                address = self.addressTextBox.text()
                # Use the written text in the text box as input
                commands = self.commandsTextBox.toPlainText()

                with open('input.txt', 'w') as f:
                    f.write(commands)

                # Use environment variable to remember IP address
                os.environ['ADDRESS'] = address

                # Run the script generator
                result = subprocess.run(
                    ["python", "script_generator.py"],
                    capture_output=True,
                    text=True,
                    check=True
                )
                print("Script output:", result.stdout)

                # Signal completion
                QtCore.QMetaObject.invokeMethod(
                    self,
                    "test_completed",
                    QtCore.Qt.ConnectionType.QueuedConnection
                )

            except subprocess.CalledProcessError as e:
                print("Error running script:", e.stderr)
                # Signal error
                QtCore.QMetaObject.invokeMethod(
                    self,
                    "test_failed",
                    QtCore.Qt.ConnectionType.QueuedConnection,
                    QtCore.Q_ARG(str, str(e))
                )

        # Start test execution in separate thread
        self.test_thread = Thread(target=run_tests)
        self.test_thread.start()

    @QtCore.pyqtSlot()
    def test_completed(self):
        """Handle test completion"""
        QtWidgets.QMessageBox.information(
            None,
            "Success",
            "Test execution completed successfully"
        )

    @QtCore.pyqtSlot(str)
    def test_failed(self, error_message):
        """Handle test failure"""
        QtWidgets.QMessageBox.critical(
            None,
            "Error",
            f"Script failed:\n{error_message}"
        )

    def update_log_display(self):
        """Update log viewer with new log data"""
        if self.log_handler:
            try:
                while not self.log_handler.log_queue.empty():
                    log_data = self.log_handler.log_queue.get_nowait()
                    if log_data:
                        self.logViewer.append(log_data)
                        # Auto-scroll to bottom
                        self.logViewer.verticalScrollBar().setValue(
                            self.logViewer.verticalScrollBar().maximum()
                        )
                        # Force GUI update
                        QtWidgets.QApplication.processEvents()
            except Exception as e:
                print(f"Error updating display: {str(e)}")


    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(900, 800)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setGeometry(QtCore.QRect(64, 445, 161, 32))
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.commandsTextBox = QtWidgets.QPlainTextEdit(parent=Dialog)
        self.commandsTextBox.setGeometry(QtCore.QRect(70, 130, 530, 301))
        self.commandsTextBox.setObjectName("commandsTextBox")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setGeometry(QtCore.QRect(70, 20, 91, 31))
        self.label.setObjectName("label")
        self.exportScriptButton = QtWidgets.QPushButton(parent=Dialog)
        self.exportScriptButton.setGeometry(QtCore.QRect(619, 445, 100, 23))
        self.exportScriptButton.setObjectName("exportScriptButton")
        self.label_2 = QtWidgets.QLabel(parent=Dialog)
        self.label_2.setGeometry(QtCore.QRect(70, 100, 171, 16))
        self.label_2.setObjectName("label_2")
        self.loadScriptButton = QtWidgets.QPushButton(parent=Dialog)
        self.loadScriptButton.setGeometry(QtCore.QRect(726, 445, 100, 23))
        self.loadScriptButton.setObjectName("loadScriptButton")
        self.addressTextBox = QtWidgets.QLineEdit(parent=Dialog)
        self.addressTextBox.setGeometry(QtCore.QRect(70, 60, 210, 23))
        self.addressTextBox.setObjectName("addressTextBox")
        self.elementNamesButton = QtWidgets.QPushButton(parent=Dialog)
        self.elementNamesButton.setGeometry(QtCore.QRect(501, 60, 100, 23))
        self.elementNamesButton.setObjectName("elementNamesButton")
        self.testQueue = QtWidgets.QListWidget(parent=Dialog)
        self.testQueue.setGeometry(QtCore.QRect(620, 130, 205, 301))
        self.testQueue.setObjectName("testQueue")
        self.instructionsButton = QtWidgets.QPushButton(parent=Dialog)
        self.instructionsButton.setGeometry(QtCore.QRect(394, 60, 100, 23))
        self.instructionsButton.setObjectName("instructionsButton")
        self.connectButton = QtWidgets.QPushButton(parent=Dialog)
        self.connectButton.setGeometry(QtCore.QRect(69, 709, 75, 23))
        self.connectButton.setObjectName("connectButton")
        self.pushButton = QtWidgets.QPushButton(parent=Dialog)
        self.pushButton.setGeometry(QtCore.QRect(151, 709, 75, 23))
        self.pushButton.setObjectName("pushButton")
        self.logViewer = QtWidgets.QTextBrowser(parent=Dialog)
        self.logViewer.setGeometry(QtCore.QRect(70, 490, 530, 201))
        font = QtGui.QFont()
        font.setFamily("Courier")
        self.logViewer.setFont(font)
        self.logViewer.setLineWrapMode(QtWidgets.QTextEdit.LineWrapMode.NoWrap)
        self.logViewer.setObjectName("logViewer")

        # Functionality for buttons
        self.loadScriptButton.clicked.connect(self.open_file_dialog)
        self.exportScriptButton.clicked.connect(self.save_file_dialog)
        self.instructionsButton.clicked.connect(self.open_instructions)
        self.testQueue.itemClicked.connect(self.on_queue_item_clicked)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(self.run_script_generator)  # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject)  # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

        self.log_update_timer = QtCore.QTimer()
        self.log_update_timer.timeout.connect(self.update_log_display)
        self.log_update_timer.setInterval(50)  # Update every 100ms

        # Connect button signal
        self.connectButton.clicked.connect(self.toggle_log_connection)

        self.test_count = 0

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.label.setText(_translate("Dialog", "Enter IP Address"))
        self.exportScriptButton.setText(_translate("Dialog", "Export"))
        self.label_2.setText(_translate("Dialog", "Enter Commands Line By Line"))
        self.loadScriptButton.setText(_translate("Dialog", "Load Previous"))
        self.elementNamesButton.setText(_translate("Dialog", "Every Element"))
        self.instructionsButton.setText(_translate("Dialog", "Commands Help"))
        self.connectButton.setText(_translate("Dialog", "Connect"))
        self.pushButton.setText(_translate("Dialog", "Clear"))

    def toggle_log_connection(self):
        """Toggle connection to device logs"""
        if not self.log_handler or not self.log_handler.connected:
            ip_address = self.addressTextBox.text()

            if not ip_address:
                QtWidgets.QMessageBox.warning(
                    None,
                    "Warning",
                    "Please enter an IP address"
                )
                return

            print(f"Attempting to connect to {ip_address}")
            self.log_handler = LogHandler(
                host=ip_address,
                port=3003  # Using port 3003 as in your example
            )

            if self.log_handler.connect():
                self.log_handler.start_logging()
                self.log_update_timer.start()
                self.connectButton.setText("Disconnect")
                self.logViewer.append("Connected to device logs...")
                print("Connection successful")
            else:
                QtWidgets.QMessageBox.critical(
                    None,
                    "Error",
                    "Failed to connect to device logs"
                )
        else:
            self.disconnect_logs()

    def disconnect_logs(self):
        if self.log_handler:
            self.log_handler.stop_logging()
            self.log_update_timer.stop()
            self.connectButton.setText("Connect to Logs")
            self.logViewer.append("Disconnected from device logs.")
            self.log_handler = None


    def update_log_display(self):
        if self.log_handler:
            while not self.log_handler.log_queue.empty():
                log_data = self.log_handler.log_queue.get()
                self.logViewer.append(log_data)
                # Auto-scroll to bottom
                self.logViewer.verticalScrollBar().setValue(
                    self.logViewer.verticalScrollBar().maximum()
                )


    # Add test runs to a queue after loading them
    def add_to_queue(self, file_path):
        try:
            file_name = os.path.basename(file_path)

            # Create list item with custom widget
            item_widget = QtWidgets.QWidget()
            layout = QtWidgets.QHBoxLayout(item_widget)
            label = QtWidgets.QLabel(file_name)
            layout.addWidget(label)

            # Remove button for each list input
            remove_button = QtWidgets.QPushButton("X")
            remove_button.setMaximumWidth(30)
            remove_button.setMaximumHeight(23)
            remove_button.clicked.connect(lambda: self.remove_from_queue(file_name))
            layout.addWidget(remove_button)

            # Create list item and add to the widget
            item = QtWidgets.QListWidgetItem()
            item.setSizeHint(item_widget.sizeHint())

            self.testQueue.addItem(item)
            self.testQueue.setItemWidget(item, item_widget)

            # Store file info
            if not hasattr(self, 'queue_files'):
                self.queue_files = {}

            with open(file_path, 'r') as f:
                content = f.read()

            self.queue_files[file_name] = {
                'path': file_path,
                'content': content,
                'item': item
            }

        except Exception as e:
            QtWidgets.QMessageBox.critical(
                None,
                "Error",
                f"Failed to add file to queue: {str(e)}"
            )


    # Delete a test run from the queue
    def remove_from_queue(self, file_name):
        if file_name in self.queue_files:
            item = self.queue_files[file_name]['item']
            self.testQueue.takeItem(self.testQueue.row(item))
            del self.queue_files[file_name]


    # Open the content inside the test run
    def on_queue_item_clicked(self, item):
        widget = self.testQueue.itemWidget(item)
        file_name = widget.layout().itemAt(0).widget().text()  # Get label text

        if file_name in self.queue_files:
            self.commandsTextBox.setPlainText(self.queue_files[file_name]['content'])


    # Handle script generation, once or multiple times
    def run_script_generator(self):
        # Check if the test run is in queue
        if not hasattr(self, 'queue_files') or not self.queue_files:
            # Run the program once
            address = self.addressTextBox.text()
            commands = self.commandsTextBox.toPlainText()
            self.run_single_test(address, commands, f"test{self.test_count}")
        else:
            # Run all tests in queue
            address = self.addressTextBox.text()
            for file_name, file_info in self.queue_files.items():
                try:
                    print(f"Running test: {file_name}")

                    test_name = os.path.splitext(file_name)[0]
                    self.run_single_test(address, file_info['content'], test_name)

                except Exception as e:
                    QtWidgets.QMessageBox.warning(
                        None,
                        "Warning",
                        f"Error running {file_name}: {str(e)}"
                    )

        if self.log_handler and self.log_handler.connected:
            # Send any necessary commands
            self.log_handler.send_command("your_command_here")


    # Taking in an IP address to run the script once
    def run_single_test(self, address, commands, test_name):
        self.test_count += 1

        with open('input.txt', 'w') as f:
            f.write(commands)

        os.environ['ADDRESS'] = address
        os.environ['TEST_NUM'] = str(self.test_count)
        os.environ['TEST_NAME'] = test_name

        try:
            result = subprocess.run(
                ["python", "script_generator.py"],
                capture_output=True,
                text=True,
                check=True
            )
            print("Script output:", result.stdout)

        except subprocess.CalledProcessError as e:
            print("Error running script:", e.stderr)
            QtWidgets.QMessageBox.critical(
                None,
                "Error",
                f"Script failed with exit code {e.returncode}:\n{e.stderr}"
            )


    # Allow user to load in an already existing test run
    def open_file_dialog(self):
        try:
            filenames, _ = QFileDialog.getOpenFileNames(
                parent=None,
                caption="Open File",
                directory="",
                filter="Text Files (*.txt);;All Files (*.*)"
            )

            # Add each selected file to the queue
            for filename in filenames:
                self.add_to_queue(filename)

        except Exception as e:
            print(f"Error opening file: {str(e)}")


    # Allow user to save their test run in a text file
    def save_file_dialog(self):
        try:
            # Get content from text box
            content = self.commandsTextBox.toPlainText()

            if not content:
                QtWidgets.QMessageBox.warning(
                    None,
                    "Warning",
                    "Nothing to save - text box is empty"
                )
                return

            # Create file dialog
            dialog = QFileDialog()
            dialog.setFileMode(QFileDialog.FileMode.AnyFile)
            dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)  # Set to Save mode
            dialog.setNameFilter("Text Files (*.txt)")
            dialog.setDefaultSuffix("txt")  # Automatically add .txt extension

            if dialog.exec() == QtWidgets.QDialog.DialogCode.Accepted:
                file_name = dialog.selectedFiles()[0]

                # Save the content to the file
                with open(file_name, 'w') as file:
                    file.write(content)

                QtWidgets.QMessageBox.information(
                    None,
                    "Success",
                    f"File saved successfully to:\n{file_name}"
                )

        except Exception as e:
            QtWidgets.QMessageBox.critical(
                None,
                "Error",
                f"Failed to save file: {str(e)}"
            )


    def open_instructions(self):
        QtWidgets.QMessageBox.information(
            None,
            "Instructions",
            "login: login,\n"
            "logout: logout,\n"
            "power cycle: power_cycle,\n"
            "check: check_element,\n"
            "screenshot: screenshot,\n"
            "check_button: check_button,\n"
            "click: click,\n"
            "power: power_toggle,\n"
            "check_text: check_text,"
        )


