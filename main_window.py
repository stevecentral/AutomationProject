# Form implementation generated from reading ui file 'main_window.ui'
#
# Created by: PyQt6 UI code generator 6.8.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


import os
import subprocess
from PyQt6.QtWidgets import QFileDialog, QWidget
from PyQt6 import QtCore, QtGui, QtWidgets
from threading import Thread

from action_functions import send_serial_command
from log_handler import LogHandler
import time


class Ui_Dialog(object):
    def __init__(self):
        self.log_handlers = {}
        self.log_update_timer = None
        self.test_thread = None
        self.queue_files = {}  # To manage queued scripts
        self.test_counter = 0
        self.connection_states = {}  # Keep track of device connection states


    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(900, 950)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setGeometry(QtCore.QRect(64, 445, 161, 23))
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.commandsTextBox = QtWidgets.QPlainTextEdit(parent=Dialog)
        self.commandsTextBox.setGeometry(QtCore.QRect(70, 130, 530, 301))
        self.commandsTextBox.setObjectName("commandsTextBox")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setGeometry(QtCore.QRect(70, 20, 91, 31))
        self.label.setObjectName("label")
        self.exportScriptButton = QtWidgets.QPushButton(parent=Dialog)
        self.exportScriptButton.setGeometry(QtCore.QRect(619, 445, 100, 23))
        self.exportScriptButton.setObjectName("exportScriptButton")
        self.label_2 = QtWidgets.QLabel(parent=Dialog)
        self.label_2.setGeometry(QtCore.QRect(70, 100, 171, 16))
        self.label_2.setObjectName("label_2")
        self.loadScriptButton = QtWidgets.QPushButton(parent=Dialog)
        self.loadScriptButton.setGeometry(QtCore.QRect(726, 445, 100, 23))
        self.loadScriptButton.setObjectName("loadScriptButton")
        self.addressTextBox = QtWidgets.QLineEdit(parent=Dialog)
        self.addressTextBox.setGeometry(QtCore.QRect(70, 60, 210, 23))
        self.addressTextBox.setObjectName("addressTextBox")
        self.elementNamesButton = QtWidgets.QPushButton(parent=Dialog)
        self.elementNamesButton.setGeometry(QtCore.QRect(501, 60, 100, 23))
        self.elementNamesButton.setObjectName("elementNamesButton")
        self.testQueue = QtWidgets.QListWidget(parent=Dialog)
        self.testQueue.setGeometry(QtCore.QRect(620, 130, 205, 301))
        self.testQueue.setObjectName("testQueue")
        self.instructionsButton = QtWidgets.QPushButton(parent=Dialog)
        self.instructionsButton.setGeometry(QtCore.QRect(394, 60, 100, 23))
        self.instructionsButton.setObjectName("instructionsButton")
        self.connectButton = QtWidgets.QPushButton(parent=Dialog)
        self.connectButton.setGeometry(QtCore.QRect(69, 709, 75, 23))
        self.connectButton.setObjectName("connectButton")
        self.clearButton = QtWidgets.QPushButton(parent=Dialog)
        self.clearButton.setGeometry(QtCore.QRect(151, 709, 75, 23))
        self.clearButton.setObjectName("clearButton")
        self.addTabButton = QtWidgets.QPushButton(parent=Dialog)
        self.addTabButton.setGeometry(QtCore.QRect(726, 709, 100, 23))
        self.addTabButton.setObjectName("addTabButton")
        self.logTabWidget = QtWidgets.QTabWidget(parent=Dialog)
        self.logTabWidget.setGeometry(QtCore.QRect(70, 480, 758, 221))
        self.logTabWidget.setObjectName("logTabWidget")
        self.tab_7 = QtWidgets.QWidget()
        self.tab_7.setObjectName("tab_7")
        self.logTabWidget.addTab(self.tab_7, "")
        self.tab_8 = QtWidgets.QWidget()
        self.tab_8.setObjectName("tab_8")
        self.logTabWidget.addTab(self.tab_8, "")
        self.apiOutput = QtWidgets.QTextBrowser(parent=Dialog)
        self.apiOutput.setGeometry(QtCore.QRect(70, 750, 758, 150))
        self.apiOutput.setObjectName("apiOutput")

        # Create a tab widget for log display
        self.logTabWidget = QtWidgets.QTabWidget(Dialog)
        self.logTabWidget.setGeometry(QtCore.QRect(70, 480, 758, 221))
        self.logTabWidget.setObjectName("logTabWidget")

        # Add a button to add new log tabs
        self.addTabButton = QtWidgets.QPushButton("Add Log Tab", Dialog)
        self.addTabButton.setGeometry(QtCore.QRect(726, 709, 100, 23))
        self.addTabButton.setObjectName("addTabButton")

        # ====== Button Functionality ======
        self.loadScriptButton.clicked.connect(self.open_file_dialog)
        self.exportScriptButton.clicked.connect(self.save_file_dialog)
        self.instructionsButton.clicked.connect(self.open_instructions)
        self.testQueue.itemClicked.connect(self.on_queue_item_clicked)
        self.connectButton.clicked.connect(self.toggle_log_connection)
        self.logTabWidget.currentChanged.connect(self.on_tab_changed)  # Handle tab changes
        self.addTabButton.clicked.connect(self.add_log_tab)
        self.clearButton.clicked.connect(self.clear_logs)

        # Translations for UI text
        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(self.run_script_generator)  # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject)  # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

        # Timer for log updates
        self.log_update_timer = QtCore.QTimer()
        self.log_update_timer.timeout.connect(self.update_logs)
        self.log_update_timer.setInterval(50)  # Update every 100ms

        self.test_count = 0

        Dialog.finished.connect(self.cleanup)


    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.label.setText(_translate("Dialog", "Enter IP Address"))
        self.exportScriptButton.setText(_translate("Dialog", "Export"))
        self.label_2.setText(_translate("Dialog", "Enter Commands Line By Line"))
        self.loadScriptButton.setText(_translate("Dialog", "Load Previous"))
        self.elementNamesButton.setText(_translate("Dialog", "Every Element"))
        self.instructionsButton.setText(_translate("Dialog", "Commands Help"))
        self.connectButton.setText(_translate("Dialog", "Connect"))
        self.clearButton.setText(_translate("Dialog", "Clear"))
        self.addTabButton.setText(_translate("Dialog", "Add Log Tab"))
        self.logTabWidget.setTabText(self.logTabWidget.indexOf(self.tab_7), _translate("Dialog", "Tab 1"))
        self.logTabWidget.setTabText(self.logTabWidget.indexOf(self.tab_8), _translate("Dialog", "Tab 2"))





    # ====== Loging Methods ======
    # Creates a new tab with device's logs
    def add_log_tab(self):
        # Prompt user for host information
        host, ok = QtWidgets.QInputDialog.getText(None, "Enter Host", "Host:")
        if not ok or not host:
            return

        # Create a new tab with a QTextEdit for logs
        tab = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout()
        text_edit = QtWidgets.QTextBrowser()
        layout.addWidget(text_edit)
        tab.setLayout(layout)

        # Add tab with label
        index = self.logTabWidget.addTab(tab, f"Log {self.logTabWidget.count() + 1} - {host}")

        # Initialize the connection state as disconnected
        self.log_handlers[index] = {'handler': None, 'host': host, 'connected': False}


    # Starts the log update thread
    def start_log_thread(self, log_handler, text_edit):
        # Start a thread to update the text edit with logs
        def update_logs():
            try:
                while log_handler.connected:
                    if not log_handler.log_queue.empty():
                        log = log_handler.log_queue.get()
                        text_edit.append(log)
                    time.sleep(0.1)
            except Exception as e:
                print(f"Error in log update thread: {e}")

        # Update log thread in the background
        Thread(target=update_logs, daemon=True).start()


    # Disconnect all log handlers when the dialog is closed
    def closeEvent(self, event):
        for log_info in self.log_handlers.values():
            log_info['handler'].disconnect()
        event.accept()


    # Update the log viewer with new log entries
    def update_logs(self):
        if self.log_handlers and not self.log_handlers.log_queue.empty():
            while not self.log_handlers.log_queue.empty():
                log_entry = self.log_handlers.log_queue.get()

                if log_entry:
                    # Ensure the log entry ends with a newline
                    if not log_entry.endswith('\n'):
                        log_entry += '\n'

                    self.logViewer.append(log_entry)
                    # Scroll to the bottom
                    self.logViewer.verticalScrollBar().setValue(
                        self.logViewer.verticalScrollBar().maximum()
                    )


    # Toggle the connection state for the current log tab
    def toggle_log_connection(self):
        current_index = self.logTabWidget.currentIndex()

        if current_index in self.log_handlers:
            log_info = self.log_handlers[current_index]
            if not log_info['connected']:
                # Attempt to connect
                log_handler = LogHandler(log_info['host'])
                if log_handler.connect():
                    # Toggle to connected
                    log_info['handler'] = log_handler
                    log_info['connected'] = True
                    self.start_log_thread(log_handler,
                                          self.logTabWidget.widget(current_index).findChild(QtWidgets.QTextEdit))
                    self.connectButton.setText("Disconnect")
                else:
                    QtWidgets.QMessageBox.critical(None,
                                                   "Error",
                                                   f"Failed to connect to {log_info['host']}")
            else:
                # Toggle to disconnected
                log_info['handler'].disconnect()
                log_info['connected'] = False
                self.connectButton.setText("Connect")


    # Update the connect button text based on the connection state of the selected tab
    def on_tab_changed(self, index):
        if index in self.log_handlers and self.log_handlers[index]['connected']:
            self.connectButton.setText("Disconnect")
        else:
            self.connectButton.setText("Connect")


    # Clear logs in the current tab
    def clear_logs(self):
        current_index = self.logTabWidget.currentIndex()
        if current_index != -1:
            current_widget = self.logTabWidget.widget(current_index)
            if current_widget:
                text_edit = current_widget.findChild(QtWidgets.QTextEdit)
                if text_edit:
                    text_edit.clear()


    # Cleanup resources by disconnecting log handlers and stopping timers
    def cleanup(self):
        if self.log_handlers:
            self.log_handlers.disconnect()
        if self.log_update_timer:
            self.log_update_timer.stop()


    # ====== Test Execution Methods ======
    # Main entry point for test execution
    def run_script_generator(self):
        try:
            # Setup logging if connected to a log handler
            if hasattr(self, 'log_handler') and self.log_handler and self.log_handler.connected:
                self.setup_logging()

            # Determine whether to run a single test or a queue of tests
            if not self.queue_files:
                self.run_single_test_thread()
            else:
                self.run_queue_tests_thread()

        except Exception as e:
            # Display an error message if test execution fails
            QtWidgets.QMessageBox.critical(
                None,
                "Error",
                f"Failed to start test execution: {str(e)}"
            )


    # Initialize log handler if it is not already set up
    def setup_logging(self):
        try:
            if not self.log_handlers:
                # Creates a new log handler
                address = self.addressTextBox.text()
                self.log_handlers = LogHandler(address, callback=self.update_logs)
                if self.log_handlers.connect():
                    # Start a timer to update logs
                    self.log_update_timer = QtCore.QTimer()
                    self.log_update_timer.timeout.connect(self.update_logs)
                    self.log_update_timer.start(100)
        except Exception as e:
            print(f"Warning: Could not setup logging: {e}")


    # Execute a single test in a separate thread
    def run_single_test_thread(self):

        def run_test():
            try:
                address = self.addressTextBox.text()
                commands = self.commandsTextBox.toPlainText()
                self.run_single_test(address, commands, "single_test")
                """
                QtCore.QMetaObject.invokeMethod(
                    self, "test_completed",
                    QtCore.Qt.ConnectionType.QueuedConnection
                )
                """
            except Exception as e:
                QtCore.QMetaObject.invokeMethod(
                    self, "test_failed",
                    QtCore.Qt.ConnectionType.QueuedConnection,
                    QtCore.Q_ARG(str, str(e))
                )

        # Start the test in a new thread
        self.test_thread = Thread(target=run_test, daemon=True)
        self.test_thread.start()


    # Execute all queued tests in a separate thread
    def run_queue_tests_thread(self):

        def run_tests():
            try:
                address = self.addressTextBox.text()
                # Iterate over each queued test file
                for file_name, file_info in self.queue_files.items():
                    try:
                        print(f"Running test: {file_name}")
                        self.run_single_test(address, file_info['content'], file_name)
                        QtCore.QMetaObject.invokeMethod(
                            self, "test_progress",
                            QtCore.Qt.ConnectionType.QueuedConnection,
                            QtCore.Q_ARG(str, file_name)
                        )


                    except Exception as e:
                        QtCore.QMetaObject.invokeMethod(
                            self, "test_failed",
                            QtCore.Qt.ConnectionType.QueuedConnection,
                            QtCore.Q_ARG(str, f"Error in {file_name}: {str(e)}")
                        )
                        return
                """
                # Notify that the queue of tests is completed
                QtCore.QMetaObject.invokeMethod(
                    self, "queue_completed",
                    QtCore.Qt.ConnectionType.QueuedConnection
                )
                """
            except Exception as e:
                # Notify if there is an error in running tests
                QtCore.QMetaObject.invokeMethod(
                    self, "test_failed",
                    QtCore.Qt.ConnectionType.QueuedConnection,
                    QtCore.Q_ARG(str, str(e))
                )

        # Start the queue of tests in a new thread
        self.test_thread = Thread(target=run_tests, daemon=True)
        self.test_thread.start()


    # Execute a single test
    def run_single_test(self, address, commands, test_name):
        self.test_counter += 1
        # Write commands to an input file
        with open('input.txt', 'w') as f:
            f.write(commands)

        os.environ['ADDRESS'] = address
        os.environ['TEST_NUM'] = str(self.test_counter)
        os.environ['TEST_NAME'] = test_name

        # Run the script generator
        result = subprocess.run(
            ["python", "script_generator.py"],
            capture_output=True,
            text=True,
            check=True
        )

        # Parse the response from stdout
        stdout_lines = result.stdout.splitlines()
        for line in stdout_lines:
            if "[SERIAL_RESPONSE]" in line:
                cleaned_response = line.replace("[SERIAL_RESPONSE]", "").strip()
                self.apiOutput.append(f"API Output:\n{cleaned_response.replace(')(', ')\n(')}")
        """
        # Notify that the single test is completed
        QtCore.QMetaObject.invokeMethod(
            self, "test_completed",
            QtCore.Qt.ConnectionType.QueuedConnection
        )
        """


    # ====== Queue Methods ======
    # Add a test script file to the queue
    def add_to_queue(self, file_path):
        try:
            file_name = os.path.basename(file_path)

            # Create a widget to represent the queue item
            item_widget = QtWidgets.QWidget()
            layout = QtWidgets.QHBoxLayout(item_widget)

            label = QtWidgets.QLabel(file_name)
            layout.addWidget(label)

            # Add a remove button to the item
            remove_button = QtWidgets.QPushButton("X")
            remove_button.setMaximumWidth(30)
            remove_button.clicked.connect(lambda: self.remove_from_queue(file_name))
            layout.addWidget(remove_button)

            # Create a list to allow items to be added to the test queue
            item = QtWidgets.QListWidgetItem()
            item.setSizeHint(item_widget.sizeHint())

            self.testQueue.addItem(item)
            self.testQueue.setItemWidget(item, item_widget)

            # Read the content of the file and store the information
            with open(file_path, 'r') as f:
                content = f.read()

            self.queue_files[file_name] = {
                'path': file_path,
                'content': content,
                'item': item
            }

        except Exception as e:
            QtWidgets.QMessageBox.critical(None, "Error", f"Failed to add file to queue: {str(e)}")


    # Remove a test script file from the queue
    def remove_from_queue(self, file_name):
        if file_name in self.queue_files:
            item = self.queue_files[file_name]['item']
            self.testQueue.takeItem(self.testQueue.row(item))
            del self.queue_files[file_name]


    # Handles when a queue item is clicked on
    def on_queue_item_clicked(self, item):
        try:
            widget = self.testQueue.itemWidget(item)
            if not widget:
                return

            # Get the file name from the label
            file_name = widget.layout().itemAt(0).widget().text()

            if file_name in self.queue_files:
                # Display the content in the commands text box
                self.commandsTextBox.setPlainText(self.queue_files[file_name]['content'])

                # Optionally highlight or mark the selected item
                for i in range(self.testQueue.count()):
                    item_widget = self.testQueue.itemWidget(self.testQueue.item(i))
                    if item_widget:
                        item_widget.setStyleSheet("")

                # Highlight the selected widget
                widget.setStyleSheet("background-color: #e0e0e0;")

        except Exception as e:
            print(f"Error displaying test content: {e}")


    # Open a dialog to save the content of the commands text box to a file
    def save_file_dialog(self):
        try:
            content = self.commandsTextBox.toPlainText()
            if not content:
                QtWidgets.QMessageBox.warning(None, "Warning", "Nothing to save - text box is empty")
                return

            # Form the file dialog for saving
            dialog = QFileDialog()
            dialog.setFileMode(QFileDialog.FileMode.AnyFile)
            dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)
            dialog.setNameFilter("Text Files (*.txt)")
            dialog.setDefaultSuffix("txt")

            if dialog.exec() == QtWidgets.QDialog.DialogCode.Accepted:
                file_name = dialog.selectedFiles()[0]
                with open(file_name, 'w') as file:
                    file.write(content)
                QtWidgets.QMessageBox.information(None, "Success", f"File saved successfully to:\n{file_name}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(None, "Error", f"Failed to save file: {str(e)}")


    # Open a dialog to select files and add them to the queue
    def open_file_dialog(self):
        try:
            filenames, _ = QtWidgets.QFileDialog.getOpenFileNames(
                parent=None,
                caption="Open File",
                directory="",
                filter="Text Files (*.txt);;All Files (*.*)"
            )

            # Add each file element to the queue
            for filename in filenames:
                self.add_to_queue(filename)
        except Exception as e:
            print(f"Error opening file: {str(e)}")


    # ====== Decorator Windows ======
    @QtCore.pyqtSlot()
    def test_completed(self):
        """Handle test completion"""
        QtWidgets.QMessageBox.information(None, "Success", "Test execution completed successfully")


    @QtCore.pyqtSlot(str)
    def test_progress(self, file_name):
        """Handle test progress"""
        print(f"Completed test: {file_name}")


    @QtCore.pyqtSlot()
    def queue_completed(self):
        """Handle queue completion"""
        QtWidgets.QMessageBox.information(None, "Success", "All queued tests completed successfully")


    @QtCore.pyqtSlot(str)
    def test_failed(self, error_message):
        """Handle test failure"""
        QtWidgets.QMessageBox.critical(None, "Error", f"Script failed:\n{error_message}")


    def open_instructions(self):
        QtWidgets.QMessageBox.setGeometry(300, 300, 300, 300)
        QtWidgets.QMessageBox.information(
            None,
            "Instructions",
            "login: login,\n"
            "logout: logout,\n"
            "power cycle: power_cycle,\n"
            "check: check_element,\n"
            "screenshot: screenshot,\n"
            "check_button: check_button,\n"
            "click: click,\n"
            "power: power_toggle,\n"
            "check_text: check_text,"
        )


class AnotherWindow(QWidget):
    def __init__(self):
        super().__init__()
        layout = QtWidgets.QVBoxLayout()
        self.label = QtWidgets.QLabel("Instructions")
        layout.addWidget(self.label)
        self.setLayout(layout)
        
